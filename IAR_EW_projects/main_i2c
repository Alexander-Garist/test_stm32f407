//I2C чтение/запись побайтно и сразу несколько байт 
#include <stdio.h>

#include "stm32f4xx.h"

#include "systick.h"
#include "gpio.h"
#include "exti.h"
#include "i2c.h"

#define TIME_SHORT  10      //Время моргания светодиодов в 3 режимах
#define TIME_MEDIUM 30
#define TIME_LONG   50

#define BUTTON_TRIGGER  EXTI_TRIGGER_FALLING    //Триггер внешнего прерывания при нажатии кнопки

static uint32_t time_delay = 10;                //Время задержки в тиках systick_counter
static uint32_t time_ms_one_interrupt = 10;     //Время в мс, за которое вызывается SysTick_Handler() 1 раз

volatile static uint32_t blink_mode = 0;        //Выбор режима моргания
                                            //0 - моргают 4 светодиода быстро
                                            //1 - моргает зеленый со средней частотой
                                            //2 - моргает красный медленно
void set_time_delay(uint32_t time)                                          //callback функция для установки частоты моргания
{
    time_delay = time;
}
void change_blink_mode(void (*callback)(uint32_t))                          //Функция изменения режима моргания, вызывается в обработчике внешнего прерывания EXTI0_IRQHandler
{
    blink_mode++;                               //Нажатие кнопки переключает режим моргания на следующий
    if(blink_mode > 2) blink_mode %= 3;         //Защита от переполнения количества режимов моргания

    if(blink_mode == 0)callback(TIME_SHORT);    //time_delay = TIME_SHORT;
    if(blink_mode == 1)callback(TIME_MEDIUM);   //time_delay = TIME_MEDIUM;
    if(blink_mode == 2)callback(TIME_LONG);     //time_delay = TIME_LONG;
}
void LED_turnON_4_LED(void)                                                 //Включить все 4 светодиода
{
    GPIO_set_HIGH(GPIOD, 12);
    GPIO_set_HIGH(GPIOD, 13);
    GPIO_set_HIGH(GPIOD, 14);
    GPIO_set_HIGH(GPIOD, 15);
}
void LED_turnOFF_4_LED(void)                                               //Выключить все 4 светодиода
{
    GPIO_set_LOW(GPIOD, 12);
    GPIO_set_LOW(GPIOD, 13);
    GPIO_set_LOW(GPIOD, 14);
    GPIO_set_LOW(GPIOD, 15);
}
void EXTI0_IRQHandler(void)                                                 //Обработчик внешнего прерывания (нажатия кнопки на выводе PA0)
{
    GPIO_set_HIGH(GPIOD, 15);               //Индикация нажатия кнопки синим светодиодом
    delay_ms(100);                          //Блокирующая задержка 100мс для защиты от дребезга кнопки

    change_blink_mode(set_time_delay);      //Логика нажатия на кнопку - смена режима
    EXTI_Clear_Flag(0);                     //Сброс флага для выхода из прерывания

    LED_turnOFF_4_LED();                   //Выключение всех светодиодов
}

#define EEPROM_ADDRESS      0x50        //7-битный адрес подключенного модуля EEPROM, пины A0, A1 подтянуты к земле 1010000
#define REGISTER_ADDRESS    0xA0        //Адрес в памяти EEPROM, куда записываются данные

#define length_Transmitted_Data     20        //количество отправленных байт в память EEPROM
#define length_Received_Data        20        //количество считанных байт из памяти EEPROM
int main()
{
    //============Логика до подключения I2C========================
    //===Инициализация портов GPIO на вход и выход=================
    //===Включение обработки внешних прерываний====================
    //===Включение системного таймера для неблокирующих задержек===
    GPIO_Button_Enable(GPIOA, 0);                           //Определение порта PA0 как вход с кнопкой
    EXTI_Enable_Pin(EXTI_PortA, 0, BUTTON_TRIGGER);         //Включить внешние прерывания для этого пина

    LED_turnOFF_4_LED();                                    //В начальный момент времени все светодиоды выключены

    SysTick_Enable(time_ms_one_interrupt);                  //Включение SysTick, аргумент - требуемый период увеличения счетчика тиков
    //uint32_t timeON = get_current_time();                 //Момент отсчета времени для задержки моргания

    //uint8_t Transmitted_Byte = 0x00;
    uint8_t Transmitted_Data[length_Transmitted_Data] = {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A};

    //uint8_t Received_Byte = 0x00;
    uint8_t Received_Data[length_Received_Data];


    //============I2C==============================================
    //===Инициализация портов GPIO в режиме альтернативной функции=

    GPIO_Enable_AF_Mode(GPIOB, 7, 4);   //Определение PB7 как SDA
    GPIO_Enable_AF_Mode(GPIOB, 6, 4);   //Определение PB6 как SCL

    //===Включение модуля I2C на выбранных портах GPIO=============

    I2C_Enable_Pin(I2C1);

    I2C_is_Device_Ready(I2C1, EEPROM_ADDRESS);
    GPIO_set_HIGH(GPIOD, 15);   //Синий моргнул - EEPROM готова
    delay_ms(1000);
    GPIO_set_LOW(GPIOD, 15);
    delay_ms(1000);

   //===проверка функций чтения/записи===
    uint16_t START = 0xB0;
/*   //прием/передача побайтно в цикле
     for(int i = 0; i < length_Transmitted_Data; i++)
    {
        //отправка
        Transmitted_Byte = Transmitted_Data[i];
        I2C_Write_Byte(I2C1, EEPROM_ADDRESS, START + i, Transmitted_Byte);
        GPIO_set_HIGH(GPIOD, 12);   //зеленый - удалось отправить 1 байт
        delay_ms(500);

        //прием
        I2C_Read_Byte(I2C1, EEPROM_ADDRESS, START + i, &Received_Byte);
        GPIO_set_HIGH(GPIOD, 13);   //оранжевый - удалось прочитать 1 байт
        delay_ms(500);
        printf("Received_Byte: 0x%02X from address: 0x%02X\n", Received_Byte, START + i);
        Received_Byte = 0x00;
    }
*/

/*    //отправка сразу нескольких байт, прием по одному в цикле
    I2C_Write_Bytes(I2C1, EEPROM_ADDRESS, START, Transmitted_Data, length_Transmitted_Data);

    for(int i = 0; i < length_Transmitted_Data; i++)
    {
        //прием
        I2C_Read_Byte(I2C1, EEPROM_ADDRESS, START + i, &Received_Byte);
        GPIO_set_HIGH(GPIOD, 13);   //оранжевый - удалось прочитать 1 байт
        delay_ms(500);
        printf("Received_Byte: 0x%02X from address: 0x%02X\n", Received_Byte, START + i);
        Received_Byte = 0x00;
    }
*/

    //отправка сразу нескольких байт и прием сразу нескольких байт
    I2C_Write_Bytes(I2C1, EEPROM_ADDRESS, START, Transmitted_Data, length_Transmitted_Data);
    GPIO_set_HIGH(GPIOD, 12);
    delay_ms(10);
    I2C_Read_Bytes(I2C1, EEPROM_ADDRESS, START, Received_Data, length_Received_Data);
    GPIO_set_HIGH(GPIOD, 14);

    //вывод для отладки
   for(int i = 0; i < length_Received_Data; i++)
    {
        printf("Received_Byte: %c from address: 0x%02X\n", Received_Data[i], START + i);
    }


    uint32_t timeON = get_current_time();       //Момент отсчета времени для основного цикла
    while(1)
    {
        if(is_time_passed(timeON, time_delay))
        {
            LED_turnOFF_4_LED();
        }
        if(is_time_passed(timeON, time_delay * 2))
        {
            switch(blink_mode)
            {
                case 0: LED_turnON_4_LED();         break;
                case 1: GPIO_set_HIGH(GPIOD, 12);   break;
                case 2: GPIO_set_HIGH(GPIOD, 14);   break;
            }
            timeON = get_current_time();
        }
    }
}