#include <stdio.h>			//нужно убрать дублирующиеся функции чтения/записи 1 байта или нескольких, функции должны возвращать статус выполнения/ошибки
#include "i2c.h"

static void I2C_RCC_Enable(I2C_TypeDef* port)   //Включение тактирования порта I2C (1,2 или 3)
{
    /*switch((uint32_t)port)                      //Выбор порта I2C через switch
    {
    case ((uint32_t)I2C1): RCC->APB1ENR |= RCC_APB1ENR_I2C1EN; break;
    case ((uint32_t)I2C2): RCC->APB1ENR |= RCC_APB1ENR_I2C2EN; break;
    case ((uint32_t)I2C3): RCC->APB1ENR |= RCC_APB1ENR_I2C3EN; break;
    }*/

    //===По аналогии с тактированием конкретного порта GPIO===
    uint32_t Address_Shift = (uint32_t)port - (uint32_t)I2C1;   //Расчет сдвига порта от I2C1_BASE
    Address_Shift /= 1024;                                      //Сдвиг каждого порта от I2C1_BASE составляет 0x0400, в десятичной системе это 1024

    uint32_t RCC_Enable_Mask[] = {      //Массив с масками для включения тактирования конкретного порта I2C
        RCC_APB1ENR_I2C1EN,
        RCC_APB1ENR_I2C2EN,
        RCC_APB1ENR_I2C3EN
    };
    RCC->APB1ENR |= RCC_Enable_Mask[Address_Shift];     //Включение только нужного порта
}
static void I2C_Init_Pin(I2C_TypeDef* port)     //Инициализация выбранного порта I2C
{
    port->CR1 &= ~I2C_CR1_PE;       //сброс флага PE для настройки I2C
    port->CR1 |= I2C_CR1_SWRST;     //Сброс I2C перед работой
    delay_ms(1);
    port->CR1 &= ~I2C_CR1_SWRST;

    //port->CR2 &= ~I2C_CR2_FREQ; //Сначала нули
    port->CR2 = 16;     //Установка частоты периферийных устройств (0x10 == 16 МГц)
    port->CCR = 80;     //Установка частоты I2C 100 кГц     половина частоты APB / желаемая частота : 8 000 000 / 100 000 = 80 (0x50)
    port->TRISE = 6;    //Максимальное время подъема SCL

    port->CR1 |= I2C_CR1_PE;    //Включение I2C (Peripheral Enable)
    delay_ms(10);
}
static void I2C_Wait_Flag_SR1(I2C_TypeDef* port, uint16_t flag)                 //Ожидание установки флага состояния SR1
{
    while(!(port->SR1 & flag)){}
}
static void I2C_Wait_Bus_Busy(I2C_TypeDef* port)                                //Ожидание освобождения шины
{
    while(port->SR2 & I2C_SR2_BUSY){}
}
static void I2C_Start(I2C_TypeDef* port, uint8_t address, uint8_t direction)    //Начало передачи по I2C
{
    //Генерация START
    port->CR1 |= I2C_CR1_START;
    I2C_Wait_Flag_SR1(port, I2C_SR1_SB);

    //Отправка запроса
    port->DR = (address << 1) | direction;
    I2C_Wait_Flag_SR1(port, I2C_SR1_ADDR);

    (void)port->SR2;//Очистка ADDR
}
static void I2C_Stop(I2C_TypeDef* port)                                         //Окончание передачи по I2C
{
    port->CR1 |= I2C_CR1_STOP;
    delay_ms(1);
}



//===========================Публичные функции========================================================================
void I2C_Enable_Pin(I2C_TypeDef* port)                                  //Разрешение использовать конкретный I2C (I2C1, I2C2, I2C3)
{
    I2C_RCC_Enable(port);   //Включение тактирования I2C
    I2C_Init_Pin(port);     //Сброс перед работой, настройка частоты
}
void I2C_is_Device_Ready(I2C_TypeDef* port, uint8_t device_addr)        //Проверка готовности подключенного устройства
{
    I2C_Start(port, device_addr, 0);
    I2C_Stop(port);
}
//===Публичные функции чтения/записи===
void I2C_Write_Byte(I2C_TypeDef* port, uint8_t device_addr, uint16_t reg_addr, uint8_t data)        //Запись одного байта данных
{
    I2C_Wait_Bus_Busy(port);                 //Ожидание освобождения шины I2C, шина освобождается после генерации состояния STOP на шине
    I2C_Start(port, device_addr, 0);    //Генерация состояния START и отправка запроса на запись подключенному устройству

    //Отправка 2 8-битных слов адреса
    port->DR = (reg_addr >> 8) & 0xFF;      //старший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = reg_addr & 0xFF;             //младший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = data;                        //Запись 1 байта данных
    I2C_Wait_Flag_SR1(port, I2C_SR1_BTF);

    I2C_Stop(port);                         //Генерация состояния STOP для освобождения шины
}
void I2C_Read_Byte(I2C_TypeDef* port, uint8_t device_addr, uint16_t reg_addr, uint8_t* data)        //Чтение одного байта данных
{
    //if(data == NULL) return 0;
    I2C_Wait_Bus_Busy(port);                //Ожидание освобождения шины I2C, шина освобождается после генерации состояния STOP на шине
    I2C_Start(port, device_addr, 0);        //Генерация состояния START и отправка запроса на запись подключенному устройству
                                            //(сначала запись, т.к. нужно отправить адрес, с которого нужно считывать данные)

    //Отправка 2 8-битных слов адреса
    port->DR = (reg_addr >> 8) & 0xFF;      //старший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = reg_addr & 0xFF;             //младший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    I2C_Start(port, device_addr, 1);        //Повторная генерация START уже для чтения

    port->CR1 &= ~I2C_CR1_ACK;  //одиночное чтение, поэтому ACK отключен

    I2C_Stop(port);             //Генерация состояния STOP для освобождения шины
    I2C_Wait_Flag_SR1(port,I2C_SR1_RXNE);

    *data = port->DR;
}
void I2C_Write_Bytes(I2C_TypeDef* port, uint8_t device_addr, uint16_t reg_addr, uint8_t* data, uint16_t size)        //Запись нескольких байт данных
{
    I2C_Wait_Bus_Busy(port);            //Ожидание освобождения шины I2C, шина освобождается после генерации состояния STOP на шине
    I2C_Start(port, device_addr, 0);    //Генерация состояния START и отправка запроса на запись подключенному устройству

    //Отправка 2 8-битных слов адреса
    port->DR = (reg_addr >> 8) & 0xFF;      //старший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = reg_addr & 0xFF;             //младший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    //Отправка данных
    for(uint16_t i = 0; i < size; i++)
    {
        port->DR = data[i];
        I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);   //Data Register Empty (transmitters)
    }

    I2C_Wait_Flag_SR1(port, I2C_SR1_BTF);       //Byte Transfer Finished
    I2C_Stop(port);
    delay_ms(10);
}
void I2C_Read_Bytes(I2C_TypeDef* port, uint8_t device_addr, uint16_t reg_addr, uint8_t* data, uint16_t size)         //Чтение нескольких байт данных
{
    //if(data == NULL) return 0;
    I2C_Wait_Bus_Busy(port);                //Ожидание освобождения шины I2C, шина освобождается после генерации состояния STOP на шине
    I2C_Start(port, device_addr, 0);        //Генерация состояния START и отправка запроса на запись подключенному устройству
                                            //(сначала запись, т.к. нужно отправить адрес, с которого нужно считывать данные)

    //Отправка 2 8-битных слов адреса
    port->DR = (reg_addr >> 8) & 0xFF;      //старший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = reg_addr & 0xFF;             //младший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_BTF);

    I2C_Start(port, device_addr, 1);        //Повторный старт для чтения

    if(size > 1){
        port->CR1 |= I2C_CR1_ACK;        //Чтение нескольких байт, Acknowledge Enable
    }
    else{
        port->CR1 &= ~I2C_CR1_ACK;      //Одиночное чтение, сброс Acknowledge Disable
    }
    (void)port->SR2;

    for(uint16_t i = 0; i < size; i++)
    {
        if(i == size - 1)       //При чтении последнего байта нужно сбросить флаг ACK и остановить прием данных
        {
            port->CR1 &= ~I2C_CR1_ACK;
            I2C_Stop(port);
        }
        I2C_Wait_Flag_SR1(port, I2C_SR1_RXNE);  //Data Register not Empty (receivers)
        data[i] = port->DR;
    }
}
//===============================

typedef enum
{
    I2C_DATA_NULL = 0,
    I2C_OK =    1
}I2C_Status;


I2C_Status read(I2C_TypeDef* port, uint8_t device_addr, uint16_t reg_addr, uint8_t* data, uint16_t size)
{
    if(data == NULL) return I2C_DATA_NULL;
    I2C_Wait_Bus_Busy(port);                //Ожидание освобождения шины I2C, шина освобождается после генерации состояния STOP на шине
    I2C_Start(port, device_addr, 0);        //Генерация состояния START и отправка запроса на запись подключенному устройству
                                            //(сначала запись, т.к. нужно отправить адрес, с которого нужно считывать данные)

    //Отправка 2 8-битных слов адреса
    port->DR = (reg_addr >> 8) & 0xFF;      //старший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    port->DR = reg_addr & 0xFF;             //младший байт адреса
    I2C_Wait_Flag_SR1(port, I2C_SR1_TXE);

    I2C_Start(port, device_addr, 1);        //Повторная генерация START уже для чтения

    port->CR1 &= ~I2C_CR1_ACK;  //одиночное чтение, поэтому ACK отключен

    I2C_Stop(port);             //Генерация состояния STOP для освобождения шины
    I2C_Wait_Flag_SR1(port,I2C_SR1_RXNE);

    *data = port->DR;
    return I2C_OK;

}